# 恶意代码分析与防治技术实验报告——`Lab13`

> **学号：2013921  
姓名：周延霖  
专业：信息安全**



## 一、实验环境
---

本人的本机是`macOS Montery 12.4`，在本机和在`Windows XP`的虚拟机下共同完成相应的程序的运行以及完成恶意代码分析的实验。


## 二、实验工具
---


本次实验主要了解恶意代码一些常见功能，并利用IDA Pro等工具进行分析，现将其列举如下：
- `IDA Python`
- `IDA Pro`
- `yara`
- `process monitor`
- `OllyDBG`
- `winhex`



## 三、实验目的
---

恶意代码编写者与恶意代码分析人员都在不断提高他们的能力和技巧。为了逃避检测与阻挠分析，恶意代码编写者用越来越多的方法来保护他们的目的、技术及通信内容。他们使用的主要工具是编码和加密。编码不仅仅影响通信，它也可以使恶意代码更加难以分析和理解。幸运的是，利用合适的工具，正在使用的很多技术都相对容易识别与对付。

本章涵盖了恶意代码最常使用的加密和解密技术。也讨论识别，了解它们的一些工具和技术，同时还讨论了恶意代码使用的编码和解码方法。

本章侧重于通用的加密算法，并且解释了如何识别它们以及如何执行解密。下一章，我们会专门介绍恶意代码是如何使用网络命令和控制的。在许多情况下，这种网络命令和控制浏览是加密的，但是仍然可能创建可靠的特征探测恶意通信。

数据加密指的是以隐藏恶意代码目的的加密行为，分析加密算法有两步骤：`识别，解密`

### ***简单加密算法***

特点：使用代码量少

**凯撒密码：** 字符串向右移动字符

**异或加密：** 异或加密只需要一个字符即可，单字节加密可通过暴力破解来解密（暴力破解识别）

- 保留NULL的单字节XOR加密：遇到NULL和密钥本身则不加密，这种更隐蔽
- 分析的时候看到异或在循环里，可能是在加解密

其他简单算法：

- ADD和SUB组合：一个加，一个减，配套使用
- ROL，ROR：旋转字节左右的比特位
- ROT：凯撒密码，通常使用可打印字符
- Multibyte：按块（4字节或8字节）进行异或
- 链或环：使用内容本身作为密钥，最常见的是原始密钥在明文两端，编码过的输出字符作为下一个字符的密钥


Base64：比较常见，广泛用于HTTP和XML

- 长度有限的随机字符，如果被补齐，长度通常可以被4整除
- 通常填充字符是`=`
- Base64加密最精彩的地方是可以自定义加密索引

### ***常见加密算法***

可以通过识别字符串和导入来判断使用了什么加密库

通过识别加密常量也可以获取加密相关信息，使用IDA的插件可进行操作

另一种识别方法是通过查找高熵值内容

通过组合加密手段来进行自定义加密

### ***解密***

最经济的解密方法是把程序运行起来让其自解密

也可以手动执行解密函数，自己编写解密函数或者调用程序自己的解密函数


## 四、实验内容
---


### *lab13-1*



#### 分析恶意代码文件Lab13-01.exe。



> Q1.比较恶意代码中的字符串 （字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？

网络中出现两个恶意代码中不存在的字符串（当 strings 命令运行时，并没有字符串输出）。一个字符串是域名`www.practicalmalwareanalysis.com`， 另外一-个是GET 请求路径，它看起来像 `aG9zdG5hbWUtZm9v`。

加密的是要访问的恶意网站，在main函数中，最上面进行了字符串解密，然后在网络功能初始化之后使用该字符串作为参数进行操作，应该是网址，如下图所示：

![](https://i.imgtg.com/2022/12/07/DnT8b.png)



> Q2.使用 IDA PrO 搜索恶意代码中宇符串‘xor’，以此来查找潜在的加密，你发现了哪些加密类型？

地址004011B8 处的xor指令是`sub 401190` 函数中一个单字节 XOR 加密循环的指令。

这里是异或加密，如下图所示：

![](https://i.imgtg.com/2022/12/07/Dn5n6.png)


> Q3.恶意代码使用什么密钥加密，加密了什么内容？


单字节 XOR 加密使用字节 0x3B。用 101 索引原始的数据源解密的 XOR 加密缓冲区的内容是`www.practicalmalwareanalysis.com`。

使用异或字符0x3B（59）加密，加密了网址，如下图所示：

![](https://i.imgtg.com/2022/12/07/DnowF.png)


> Q4.使用静态工具 `FindCrypt2`、`Krypto ANALyzer(KANAL）`以及 `IDA `熵插件识别一些其他类型的加密机制，你发现了什么？



用插件 PEiD KANAL 和IDA 熵，可识别出恶意代码使用标准的 Base64 编码字符串:`ABCDEFGHIJKLMNOPORSTUVWXYZabcdefghiiklmnopgrstuvwxvz0123456789+/`




> Q5.什么类型的加密被恶意代码用来发送部分网络流量？


标准的 Base64 编码用来创建 GET 请求字符串，抓包看到发送的请求包的地址还有疑似乱码的东西：解码可得：selph-da2ba2

![](https://i.imgtg.com/2022/12/07/DnaSD.png)




> Q6.Base64 编码函数在反汇编的何处？


Base64 加密函数从 0x004010B1 处开始，在sub_4010B1，这个函数对字符串进行处理，3位一组，是base64编码的特征，如下图所示：

![](https://i.imgtg.com/2022/12/07/DnBDP.png)




> Q7.恶意代码发送的Base64 加密数据的最大长度是什么？加密了什么内容？



Base64 加密前，Lab13-01.exe 复制最大 12个字节的主机名，这使得 GET 请求的宇符串的最大字符个数是 16。




> Q8.恶意代码中，你是否在 Base64 加密数据中看到了填充字符（=或者==）？



如果主机名小于 12个字节并且不能被3整除，则可能使用填充字符，当base64编码位数不足的时候，会使用=填充：

![](https://i.imgtg.com/2022/12/07/DnWkl.png)



> Q9.这个恶意代码做了什么？



Lab13-01.exe 用加密的主机名发送一个特定信号，直到接收特定的回应后退出，让攻击者知道该主机在运行




### *lab13-2*



#### 分析恶意代码文件Lab13-02.exe。



> Q1.使用动态分析，确定恶意代码创建了什么？

Lab13-02.exe 在当前目录下创建一些较大且看似随机的文件，这些文件的命名以temp 开始，以不同的 8 个十六进制数字结束，每10s，在exe所在目录创建一个temp文件，如下图所示：

![](https://i.imgtg.com/2022/12/07/Dnbpg.png)



> Q2.使用静态分析技术，例如`xor` 指令搜索、`FindCrypt2`、`KANAL` 以及`IDA` 熵插件，查找潜在的加密，你发现了什么？

XOR 搜索技术在`sub 401570` 和`sub 401739` 中识别了加密相关的函数。其他3种推荐的技术并没有发现什么，发现这两个函数里有好多异或指令：

![](https://i.imgtg.com/2022/12/07/DnkfB.png)



> Q3.基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据？


`WirteFile `调用之前可能会发现加密函数。




> Q4.加密函数在反汇编的何处？


加密函数是 `sub 40181F`.

函数sub_401000：WriteFile参数中的Buffer，还有CreateFile的文件名，都是参数传过来的，也就是说需要在调用这里之前去看看，如下图所示：

![](https://i.imgtg.com/2022/12/07/Dnz5s.png)


是sub_401851调用的sub_401000函数，sub_201851：这里调用了两个函数，sub_401070应该是写入内容到缓冲区，然后sub_40181F应该是加密，这里知道了文件名是怎么一回事，如下图所示：

![](https://i.imgtg.com/2022/12/07/DnFKK.png)




> Q5.从加密函数追溯原始的加密内容，原始加密内容是什么？


原内容是屏幕截图，跟进上面推测的sub_401070函数查看：是桌面截图的功能，这里应该是把截图内容加密存储了，如下图所示：

![](https://i.imgtg.com/2022/12/07/Dnh0a.png)




> Q6.你是否能够找到加密算法？如果没有，你如何解密这些内容？



加密算法是不标准算法，并且不容易识别，最简单方法是通过解密工具解密流量。



> Q7.使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？


分析的过程中始终都没看到加密函数,只剩下`heavy_xor`了,可以推测这个函数就是加密函数,而且加密的是那个窗口截图的信息,结合前面分析知道函数里面存在很多xor运算,简单看一下`single_xor`,注意到函数里面只是很多简单的运算操作,可以推测他是完成某个指定的特殊运算

看一下`sub_40181f`注意到一个循环结构,循环判断条件事var_4>=参数numbyte,并且每次循环var_4加10h

循环体里面一开始调用sub_4012DD,我们注意到函数调用很多的rot,也就是循环左移函数,和single_xor函数,别陷进去,这是自己设计的加密算法,分析他的代价太大不值的,我们已经知道要加密的数据是什么,和加密函数在哪里，可以完全用ollydbg动态跟踪把原始数据拷贝下来

在调用sub_40181f之前去除截屏信息,即可

在数据窗口选择复制全选,然后选择二进制复制,最后复制到winhex打开的型bmp文件即可，如下图所示：

![](https://i.imgtg.com/2022/12/07/Dn11N.png)





### *lab13-3*



#### 分析恶意代码文件Lab13-03.exe。



> Q1.比较恶意代码的输出字符串和动态分析提供的信息，通过这些比较，你发现哪些元素可能被加密？

动态分析可能找出一些看似随机的加密内容。程序的输出中没有可以识别的字符串，所以也没有什么东西暗示使用了加密。

在IDA中搜索xor，如下图所示：

![](https://beta.glilmu.com/i/2022/12/08/ikwl5g.png)




结果找到了很多xor，不过我们需要排除用于寄存器清零和库函数相关的xor指令

为了便于我们分析，可以给找到的包含剩下的xor指令的函数分别重命名为s_xor1(2,3,4,5,6)
比如：


![](https://beta.glilmu.com/i/2022/12/08/ikx1xi.png)



> Q2.使用静态分析搜索字符串 xor 来查找潜在的加密。通过这种方法，你发现什么类型的加密？

搜索 xor指令发现了6个可能与加密相关的单独函数，但是加密的类型一开始并不明显。

sub_401ac2是第一个，就重命名为s_xor1，我们使用IDA的find crypt插件来查找，如下图所示：

![](https://beta.glilmu.com/i/2022/12/08/iqsevj.png)

输出如下图所示：

![](https://beta.glilmu.com/i/2022/12/08/iqsvmc.png)


可以看到是Rijndeal算法，其实就是AES，我们先去第一处看看，查看交叉引用如下：

![](https://beta.glilmu.com/i/2022/12/08/iqt45k.png)

注意xor2,xor4通过加密常量Te0关联，再看看解密常量如下：

![](https://beta.glilmu.com/i/2022/12/08/iqth9b.png)

查看交叉引用如下：

![](https://beta.glilmu.com/i/2022/12/08/iqu6jt.png)

xor3,xor5通过解密常量Td0关联->这个有经验主义的成本，要判断哪些是加密和解密。


使用peid的krypto analyzer插件的结果如下：


![](https://beta.glilmu.com/i/2022/12/08/iquxt3.png)


上图的S，S-inv参考了S-box结构，它是一些加密算法的基本机构和IDA识别出的加密算法是一样的


> Q3.使用静态工具，如`FindCrypt2`、`KANAL` 以及`IDA` 熵插件识别一些其他类型的加密机制。发现的结果与搜索字符XOR 结果比较如何？


这三种技术都识别出了高级加密标准 AES 算法(Rijndael 算法），它与识别的6个 XOR函数相关。IDA熵插件也能识别一个自定义的 Base64 索引字符串，这表明没有明显的证据与 xor指令相关。


我们知道了s_xor2,s_xor4和AES加密相关，而s_xor3,x_xor5与AES解密相关，首先看看s_xor6，如下图所示：

![](https://beta.glilmu.com/i/2022/12/08/iwqge7.png)

这里有一个循环，004039e8处的xor指令表明该函数是用于进行XOR加密的，这里的arg_0是一个指针，指向用来进行转换的原缓冲区，arg_4也是指针，指向用来提供异或原数据的缓冲区

在循环中则是通过004039f2，004039f8指令对指向两个缓冲区的指针自增，通过004039cc对计数器变量var_4自增，接着查看s_xor6的交叉引用如下：


![](https://beta.glilmu.com/i/2022/12/08/iwr8b5.png)

先跟入sub_40352d,查看`xrefs from`：

![](https://beta.glilmu.com/i/2022/12/08/iwro7m.png)

从上图中可以看到s_xor6和s_xor2,s_xor4相关，都是加密相关的，所以可以给sub_40352d重命名为s_encrypt

还有s_xor1不知道是做什么的，可以去看看，如下图所示：

![](https://beta.glilmu.com/i/2022/12/08/iws9vn.png)

通过cmp将arg_0与0比较。如果不正确，往左边走：


![](https://beta.glilmu.com/i/2022/12/08/iwsgfn.png)

会报错空密钥，如果arg_0通过检测，则往右：


![](https://beta.glilmu.com/i/2022/12/08/iwsgac.png)

会检测arg_8是否正确，如果错误，往左走：


![](https://beta.glilmu.com/i/2022/12/08/iwsoa4.png)

会报错不正确的密钥长度，如果arg_8正确，往右走如下图所示：


![](https://beta.glilmu.com/i/2022/12/08/ixazmj.png)


此时会检测arg_c，如果错误，则往左：


![](https://beta.glilmu.com/i/2022/12/08/ixbc8f.png)

会报错不正确的块长度，那么也就是说s_xor1是密钥的初始化代码，那么s_xor1和之前那几个函数有什么关系呢

可以查看交叉引用如下：



![](https://beta.glilmu.com/i/2022/12/08/ixbfdp.png)

跟入main函数：




![](https://beta.glilmu.com/i/2022/12/08/ixbqq7.png)

在调用s_xor1之前，存在unk_412ef8的引用，00401890通过ecx将这个偏移量传入s_xor1，查看unk_412ef8的其他引用：


![](https://beta.glilmu.com/i/2022/12/08/ixbznw.png)


跟入第三处：

![](https://beta.glilmu.com/i/2022/12/08/ixcjgv.png)

可以看到，00401429将unk_412ef8的偏移量载入ecx，而随后就是s_encrypt的调用

可知unk_412ef8是一个表示AES加密器的C++对象，并且s_xor1是加密器的初始化函数，前面分析的时候说过，比较arg_0参数，如果失败则会提示空密钥，说明arg_0参数就是一个密钥

在main中调用s_xor1的地方如下：


![](https://beta.glilmu.com/i/2022/12/08/ixcvqp.png)

最近的一个push是字符串。所以我们可以认为这个字符串被用于进行AES加密

我们来回顾本次AES的流程，先用过交叉引用来到调用s_encrypt的地方如下：


![](https://beta.glilmu.com/i/2022/12/08/ixd2qm.png)

可以看到对s_encrypt的调用是在WriteFile之前：


![](https://beta.glilmu.com/i/2022/12/08/ixdhi6.png)


在ReadFile之后，而s_xor1是AES初始化函数，会在进程启动时执行，s_xor1设置的AES密码就是之前看到的那串字符串

而之前在strings窗口还看到：

![](https://beta.glilmu.com/i/2022/12/08/ixdtt1.png)

**联想到我们之前分析过的，这里可能存在base64**



> Q4.恶意代码使用哪两种加密技术？



恶意代码使用 AES 和自定义的Base64 加密。




> Q5.对于每一种加密技术，它们的密钥是什么？


AES 的密钥是`ijklmnopqrstuvwx`，自定义的Base64 加密的索引字符串是：`CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/`。

查看对其的引用：

![](https://alpha.glilmu.com/i/2022/12/08/j4jxu1.png)

跟入sub_40103f查看其交叉引用：


![](https://alpha.glilmu.com/i/2022/12/08/j4k8ha.png)


跟入sub_401082查看交叉引用：


![](https://alpha.glilmu.com/i/2022/12/08/j4k4yt.png)


跟入StartAddress：


![](https://alpha.glilmu.com/i/2022/12/08/j4kldb.png)


可以看到sub_401082是在ReadFIle和WriteFile之间被调用的，这和我们前面分析的AES很像，前面我们知道s_encrypt是在sub_40132b处被调用的：



![](https://alpha.glilmu.com/i/2022/12/08/j4ku2l.png)


查看其交叉引用来到sub_4015b7：


![](https://alpha.glilmu.com/i/2022/12/08/j4l8lm.png)


可以看到sub_10432b是一个新线程的开始，这个新线程使用CreateThread创建，所以可以给sub_40132b重命名为aes_thread，传递给线程的参数保存在lpParameter，也就是var_58中

00401826处var18移入var_58，0040182c处arg_10移入var_54，00401835处dwrord_41336c移入var_50


然后跟进aes_thread看看这些参数在函数中的流程，先看ReadFile：



![](https://alpha.glilmu.com/i/2022/12/08/j4l8w1.png)


其参数hFile来自var_BE0，往上回溯，可知其来自该函数的唯一参数：



![](https://alpha.glilmu.com/i/2022/12/08/k7uxmt.png)


回到上层函数：


![](https://alpha.glilmu.com/i/2022/12/08/k7v88y.png)


可以看到唯一的lpParameter参数来自var_58,或者说来自var_18，在看看ase_thread的WriteFile：


![](https://alpha.glilmu.com/i/2022/12/08/k7vbwg.png)


去参数hFIle来自var_BE0+4，就是var_54或者说是arg_10

我们看到var_58和var_18持有一个管道的句柄，并且这个管道的与一个shell命令的输出相连接：


![](https://alpha.glilmu.com/i/2022/12/08/k7vjvo.png)


命令hSourceHandle通过DuplicateHandle复制到shell命令的标准输出和标准错误：

![](https://alpha.glilmu.com/i/2022/12/08/k7vwdw.png)

这条shell命令由CreateProcess启动，而var_54或者说arg_10往前回溯：



![](https://alpha.glilmu.com/i/2022/12/08/k7wavi.png)


看到是sub_4015b7的唯一参数，查看交叉引用来到main：



![](https://alpha.glilmu.com/i/2022/12/08/k7wdiy.png)


如下所示：


![](https://alpha.glilmu.com/i/2022/12/08/k85jqc.png)


可知其参数来自ebp+s,而它是用connnect调用创建的一个网络套接字，那么我们也就知道了，aes_thread用于读取shell命令的输出结果，在写入网络套接字之前加密它

而base64加密函数也在一个由他们宿主进程启动的函数中使用，所以我们猜测base64线程会读取远程套接字的内容作为输入，经过解密后，再将结果发送作为命令shell的输入



> Q6.对于加密算法，它的密钥足够可靠吗？另外你必须知道什么？



对于自定义 Base64 加密的实现，索引字符串已经足够了。但是对于 AES，实现解密可能需要密钥之外的变量。如果使用密钥生成算法，则包括密钥生成算法、密钥大小、操作模式，如果需要还包括向量的初始化等。



> Q7.恶意代码做了什么？


恶意代码使用以自定义 Base64 加密算法加密传入命令和以 AES 加密传出 shell 命令响应来建立反连命令 shell。


我们已经知道了程序中有两种类型的加密。，先看看如何解密base64，脚本如下，这里是假设截取到网络通信的部分信息为BInaEi==：

![](https://alpha.glilmu.com/i/2022/12/08/lv9r62.png)

运行后得到解密结果为dir，也就是说攻击者尝试发送的是一个shell命令dir，用于列目录

再解密AES， **假设通过wireshark捕获到的加密内容为：**


![](https://alpha.glilmu.com/i/2022/12/08/lvb5lx.png)

解密脚本如下：


![](https://alpha.glilmu.com/i/2022/12/08/lvbxz8.png)


raw是我们捕获到的原始内容

- 2处是删除字符串中的空格，并将16进制转为2进制
- 3处是我们在IDA中找到的密钥
- 4处解密



运行后得到的解密结果为：


![](https://alpha.glilmu.com/i/2022/12/08/lvc19v.png)






> Q8.构造代码来解密动态分析过程中生成的一些内容，解密后的内容是什么？


**上文已经分析，这里不再赘述**





## 五、实验心得
---


这一次的实验是恶意代码与防治分析的`Lab13`实验，对理论课上讲的东西更加的熟练。

在这次实验中，了解了恶意代码最常使用的加密和解密技术，也识别，了解它们的一些工具和技术，同时还对了恶意代码使用的编码和解码方法更加的熟悉。

最后也认识到自己作为一名信息安全专业学生的责任，更加期待本学期后续的实验，希望自己能有更好的发展，`心想事成、万事胜意、未来可期`。