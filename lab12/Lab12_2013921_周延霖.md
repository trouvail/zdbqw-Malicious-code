# 恶意代码分析与防治技术实验报告——`Lab12`

> **学号：2013921  
姓名：周延霖  
专业：信息安全**



## 一、实验环境
---

本人的本机是`macOS Montery 12.4`，在本机和在`Windows XP`的虚拟机下共同完成相应的程序的运行以及完成恶意代码分析的实验。


## 二、实验工具
---


本次实验主要了解恶意代码一些常见功能，并利用IDA Pro等工具进行分析，现将其列举如下：
- `IDA Python`
- `IDA Pro`
- `yara`
- `process monitor`



## 三、实验目的
---

在本章中，我们由浅入深地探讨了常见的恶意代码隐藏启动方法。这些方法中的很多都涉及操纵系统中的实际内存。例如DLL注入、进程替换以及钩子注入等。另外一些则涉及修改硬盘上的二进制文件，如向一个PE文件增加.detour段的例子。虽然这些技术各不相同，但是它们的目的都是相同的。

为了懂得怎么发现系统中运行的恶意代码，恶意代码分析人员必须能够识别这些启动技术。识别和分析恶意代码的启动技术，是整个分析过程中必不可少的环节，因为所有的启动器只做一件事情：让恶意代码获得运行。

在下面两章中，我们将介绍恶意代码如何加密数据，以及如何通过网络进行通信。

### ***进程注入 `Process Injector`***

把恶意代码注入到别的进程中去执行，常用API：VirtualAllocEx，WriteProcessMemory函数等

- DLL注入：写一个DLL加载到目标进程中会自动执行dllmain函数

- 代码注入：注入shellcode

### ***进程替换 `Puppet process`***

创建一个合法进程，然后在其内存空间写入恶意程序，最后通过SetThreadContext函数来让入口点指向恶意代码进行执行，也叫傀儡进程

### ***Hook注入 `Hook Injector`***

使用SetWindowsHookEx来设置消息Hook

### ***APC注入 `APC Injector`***

每个线程都有一个附加的APC队列，在线程处于可警告状态的时候被处理，在这个状态的时候会一次调用APC队列中的所有函数，可通过编写代码用APC抢占可警告状态的线程

- 用户模式的APC使用API：QueueUserAPC，一般会注入目标进程的所有线程，以确保APC很快会被执行

- 内核模式的APC使用API：KeInitializeAPC，KeInsertQueueApc，一般来注入用户层shellcode到用户空间去执行



## 四、实验内容
---

- 查看程序可以看到无壳，导入表导入了CreateRemoteThread函数，有点可疑的字符串，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lBCX.png)

*这里看到了导入表没有的LoadLibraryA函数，这里大概率是个DLL注入*



### *lab12-1*



#### 分析在Lab12-01.exe 和Lab12-01.dll文件中找到的恶意代码，并确保在分析时这些文件在同一目录中



> Q1.在你运行恶意代码可执行文件时，会发生什么？

运行这个恶意代码之后，每分钟在屏幕上显示一次弹出消息，无限弹窗，一关掉就弹出来，无穷无尽：

![](https://i.imgtg.com/2022/11/28/4l5Si.png)




> Q2.哪个进程会被注入？


被注入的进程是`explorer.exe`:

![](https://i.imgtg.com/2022/11/28/4lqAL.png)


静态分析：exe程序首先动态获取几个函数地址，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lWDx.png)

然后进入for循环进行遍历获取到的进程句柄，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lUnt.png)

这里对每个进程句柄都调用了一下sub_401000函数：这个函数的功能是打开进程遍历模块看有没有名字是explorer.exe的模块在，如果有就返回1，然后主程序就会打开进程，跳出循环进入下一步，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lb6j.png)

*经典的DLL注入流程*



> Q3.你如何能够让恶意代码停止弹出窗口？

你可以重新启动`explorer.exe`进程，重启电脑也行。




> Q4.这个恶意代码样本是如何工作的？


这个恶意代码执行 DLL 注入，来在explorer.exe 中启动 Lab12-01.dll。一旦Lab12-01.dll 被注入，它在屏幕上每分钟显示一个消息框，并通过一个计数器，来显示已经过去了多少分钟，dllmain函数里直接创建了线程，如下图所示：


![](https://i.imgtg.com/2022/11/28/4lxkp.png)



线程里是个死循环：不断执行弹窗函数:

![](https://i.imgtg.com/2022/11/28/4lzpU.png)



### *lab12-2*



#### 分析在Lab12-02.exe文件中找到的恶意代码


> Q1.这个程序的目的是什么？


这个程序的目的是秘密地启动另一个程序（键盘记录器），会把在某个窗口下按键的内容记录在exe目录下的：`practicalmalwareanalysis.log`里：

![](https://i.imgtg.com/2022/11/28/4lFYY.png)

> Q2.启动器恶意代码是如何隐蔽执行的？

这个程序使用进程替换来秘密执行，程序exe是个启动器，负责启动svchost.exe，然后修改其内存为资源文件的内容，创建傀儡进程来隐蔽执行，资源中的PE文件才是真正功能模块，提取内存中解密后的资源文件拖入IDA，分析：

- 主函数首先获取两样东西：svchost.exe的绝对路径，资源头里解密后的PE文件，然后就进去函数创建傀儡进程了，如下图所示：

![](https://i.imgtg.com/2022/11/28/4li5v.png)


- 函数sub_4010EA：先判断缓冲区是不是PE文件，是的话，就创建进程svchost，启动标识为启动后挂起，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lnKq.png)

*接下来的操作就是加载PE文件到内存展开，然后设置线程上下文到PE入口点，然后恢复线程开始执行，具体操作就不细看了*



> Q3.恶意代码的负载存储在哪里？



这个恶意的有效载荷 (payload）被保存在这个程序的资源节中。这个资源节的类型是 UNICODE，且名字是 LOCALIZATION，加密存储在资源里：

![](https://i.imgtg.com/2022/11/28/4lZkI.png)


> Q4.恶意负载是如何被保护的？

保存在这个程序资源节中的恶意有效载荷是经过 XOR 编码过的。这个解码例程可以在sub 40132C处找到，而 XOR 字节在0x0040141B 处可以找到，通过加密存储来进行保护，解密程序：

![](https://i.imgtg.com/2022/11/28/4le1M.png)


> Q5.字符串列表是如何被保护的？

这些字符串是使用在sub_401000处的函数，来进行 XOR 编码的，通过异或进行保护，代码同题4。



### *lab12-3*



#### 分析在Lab12-2实验过程中抽取出的恶意代码样本，或者使用Lab12-03.exe文件．



> Q1.这个恶意负载的目的是什么？

这个程序是一个击键记录器，设置键盘钩子，监听键盘输入事件，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lvpD.png)


hook函数：向指定文件写入内容，然后继续传递消息，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lA81.png)


> Q2.恶意负载是如何注入自身的？


这个程序使用挂钩注入，来偷取击键记录，通过SetWindowsHookEx函数设置全局消息钩子来注入自身。


> Q3.这个程序还创建了哪些其他文件？


这个程序创建文件praticalmalwareanalysis.log，来保存击键记录。





### *lab12-4*



#### 分析在Lab12-04.exe文件中找到的恶意代码。


- 主函数：首先动态获取几个函数，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lrDG.png)

- 接下来进入for循环遍历进程：找到winlogon.exe进程，具体sub_401000函数分析见题1，后面的分析写题里了就，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lyfF.png)


> Q1.位置 0x401000 的代码完成了什么功能？

恶意代码查看给定 PID 是否为 winlogon.exe 进程，这里代码的功能是找到winlogon.exe模块，分析：首先填充两个字符串，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lm56.png)


接下来通过3个call来获取第一个模块的名称，然后通过字符串对比函数进行判断，对比成功则返回1，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lpKP.png)


> Q2.代码注入了哪个进程？

winlogon.exe 是被注入的进程，根据题1的分析，注入winlogon.exe进程。



> Q3.使用 LoadLibraryA 装载了哪个DLL程序？

`DLL sfc_os.dll` 用来禁用 Windows 的文件保护机制，加载了`sfc_os.dll`，紧接着循环遍历进程之后，立马调用了sub_401174函数：找到sfc.os.dll的2号函数，然后远程线程到目标进程中执行2号函数是SfcTerminateWacherThread，在下次启动之前禁用windows文件保护机制，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lJ0b.png)


> Q4.传递给 CreateRemoteThread 调用的第4个参数是什么？

传递给 CreateRemoteThread 的第4 个参数是一个函数指针，指向`sfc_os.dll`中一个未命名的序号为2的函数 (SfcTerminateWatcherThread)，和题目三类似是从dll中找到的函数地址。


> Q5.二进制主程序释放出了哪个恶意代码？


恶意代码从资源段中释放一个二进制文件，并且将这个二进制文件覆盖旧的 Windows 更新程序(wupdmgr.exe）。覆盖真实的 wupdmgr.exe之前，恶意代码将它复制到`%TEMP%`目录，供以后使用，这里先把原本的wupdmgr.exe给移动到临时目录下了，然后调用函数sub_4011FC进行资源释放，释放假的wupdmgr.exe到原位置，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lt1g.png)


> Q6.释放出恶意代码的目的是什么？

恶意代码向`winlogon.exe`注入一个远程线程，并且调用`sfc_os.dll`的一个导出函数（序号为2的`SfcTerminateWatcherThread`），在下次启动之前禁用 Windows 的文件保护机制。因为这个函数一定要运行在进程winlogon.exe 中，所以CreateRemoteThread 调用十分必要。恶意代码通过用这个二进制文件来更新自己的恶意代码，并且调用原始的二进制文件（位于%TEMP%目录）来特洛伊木马化 wupdmgr.exe 文件。

找到存起来的资源文件进行分析：执行真正的wupdmgr.exe程序，然后下载更新exe程序并执行，用来特洛伊木马化wupdmgr.exe文件，并通过下载更新文件来更新恶意代码，如下图所示：

![](https://i.imgtg.com/2022/11/28/4lPwl.png)






## 五、实验心得
---


这一次的实验是恶意代码与防治分析的`Lab12`实验，对理论课上讲的东西更加的熟练。

在这次实验中由浅入深地探讨了常见的恶意代码隐藏启动方法，例如DLL注入、进程替换以及钩子注入detour等例子，虽然这些技术各不相同，但是它们的目的都是相同的。并且懂得怎么发现系统中运行的恶意代码和启动器的让恶意代码获得运行的功能。

最后也认识到自己作为一名信息安全专业学生的责任，更加期待本学期后续的实验，希望自己能有更好的发展，`心想事成、万事胜意、未来可期`。